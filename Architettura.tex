\chapter{Architettura}
\label{chap:arch}

In questo capitolo verrá esposta l'architettura finale dell'applicativo sviluppato che permette la comunicazione tra il Surface Dial e la pagina web.\\

Il progetto si presenta suddiviso in due parti ben distinte:
\begin{itemize}
\item \textbf{Servizio Angular}.
\item \textbf{Applicazione UWP} (Universal Windows Plaform).
\end{itemize}

\section{Servizio Angular}
In Angular, i Servizi rappresentano un tassello fondamentale per la realizzazione di un'applicazione. Un servizio è solitamente rappresentato da una classe indipendente dalla View che viene definita per svolgere un compito ben preciso ed effettuare delle operazioni strettamente correlate tenendo in mente il principio di singola responsabilità.\\
È possibile definire più servizi all'interno di un'applicazione, ognuno dei quali si occupa di portare a termine un determinato incarico incrementando la modularitá del progetto, inoltre un servizio puó a sua volta dipendere da altri servizi, che vengono definiti nel costruttore del servizio stesso.\\

Avvalendosi di Angular CLI, possiamo creare un Servizio tramite il comando:

\vspace{1.0cm}
\begin{lstlisting}[caption={Esempio creazione servizio},style=javaScriptCode]
	ng generate service <nome-del-servizio> <flag-opzionali>
\end{lstlisting} 
\vspace{1.0cm}
Una volta creati, i servizi possono essere iniettati all'interno di uno o più componenti grazie al meccanismo di \emph{Dependency Injection}.\\

Per poter utilizzare un servizio da noi definito, dobbiamo registrarlo con uno degli Injector presenti in Angular. Esiste infatti una gerarchia di Injector, che Angular provvede a creare, alla base dei quali c'è il cosiddetto Root Injector, che viene creato in fase di bootstrap dell’applicazione e i servizi registrati con quest’ultimo sono disponibili per tutta l’applicazione.\\

Per ogni Injector esiste sempre una sola istanza di un determinato servizio, come specificato nella documentazione ufficiale:\\

\emph{"Services are singletons within the scope of an injector. That is, there is at most one instance of a service in a given injector."}\\

L’ Injector si occupa di creare le dipendenze e si serve di un Provider, un oggetto il quale indica all'Injector come ottenere o creare un'istanza di una dipendenza.
Per ogni dipendenza che si vuole usare nell'applicazione si deve registrare un provider con un Injector, in modo che quest'ultimo possa poi utilizzare il provider per creare nuova istanza di quella dipendenza.

\subsection{Singleton services}

Per restare in linea con le direttive utilizzare dal gruppo Loccioni nello sviluppo dei loro servizi, abbiamo utilizzato il forRoot() pattern per l’injection del servizio nell’applicazione.\\

Questo pattern permette di specificare un modulo personalizzato per il servizio, il quale contiene un metodo statico chiamato appunto forRoot() che restituisce un ModuleWithProvider parametrizzato al modulo del Servizio.\\

Questo pattern permette di effettuare l’import del modulo nell’AppModule richiamando il metodo forRoot(), cosi da non dover appesantire il Provider del modulo iniziale e in linea di principio é bene utilizzarlo quando un provider prende in ingresso dei parametri, così da non dover specificarli ogni qualvolta il modulo venga utilizzato.

\subsection{DialService}

Lo scopo finale del servizio che abbiamo implementato é quello di poterlo utilizzare come ponte o intermediario tra il Surface Dial, che si interfaccia nativamente con l'applicazione UWP, la quale contiene una WebView con all'interno caricata una pagina custom Loccioni, e i componenti della View all'interno della pagina che intendono utilizzare il servizio.\\

Il componente che dipenderá da questo determinato servizio, chiamato appunto DialService, potrá facilmente utilizzare le funzionalitá messe a disposizione dal Surface Dial e interpretare gli eventi intercettati a RunTime.\\

Il core del servizio implementato è rappresentato dalla Classe DialService, essa infatti si occupa di inizializzare il servizio e rendere disponibile la comunicazione bi-direzionale tra il lato Web e quello UWP.\\

In particolare si occupa di recuperare l'oggetto C\# iniettato a sua volta dentro l'oggetto window della pagina web, con visibilitá globale.\\

\vspace{1.0cm}
\begin{lstlisting}[caption={Recupero oggetto C\#},style=javaScriptCode]
	this.dial = (window as any).dial;
\end{lstlisting} 
\vspace{1.0cm}

L'oggetto dial viene poi inserito per questioni di sicurezza in una classe DialProxy, la quale implementa a sua volta l'interfaccia da noi sviluppata DialBackendBridge, nella quale sono presenti tutte le funzionalitá dell'oggetto "dial", richiamabili quindi da Web.

\subsection{DialProxy}

Al fine di aggiungere un livello di sicurezza sull’oggetto iniettato e sul suo successivo utilizzo, abbiamo deciso di implementare una classe chiamata DialProxy con la responsabilitá di wrappare l’oggetto e quindi di intercettare le chiamate fatte su di esso.\\

La classe DialProxy prende quindi in ingresso nel suo costruttore un oggetto di tipo DialBackendBridge, che rappresenta l'oggetto iniettato, e come secondo parametro il servizio DialService per poter accedere rapidamente alle proprietá del servizio e poter effettuare determinati controlli prima di richiamare un metodo.\\

\vspace{1.0cm}
\begin{lstlisting}[caption={Wrapping oggetto recuperato},style=javaScriptCode]
	this.dialProxy = new DialProxy(this.dial, this);
\end{lstlisting} 
\vspace{1.0cm}

\newpage
\subsection{DialBackendBridge}

DialBeckendBridge rappresenta l'interfaccia contenente la dichiarazione dei metodi implementati nella classe DialController dell'applicazione UWP.\\
In questo modo, tramite l'oggetto dial iniettato, sará possibile richiamare a RunTime i metodi dichiarati nel C\# attraverso il Web.\\

\vspace{1.0cm}
\begin{lstlisting}[caption={Interfaccia DialBackendBridge},style=javaScriptCode]
export interface DialBackednBridge{
		
	getProductId(): string;
	
	setMenu(arrayOfItem: any[]): void;
	
	clearMenu(): void;
	
	deleteItem(tag: string): void;
	
	addItem(item: any): void;
	
	createDialMenuItem(tag: string, displayText: string, icon: string): any;
	
	setDefaultItem(defaultItems: string[]): void;
	
	manualInvoke(tag: string): void;		

}		
\end{lstlisting} 
\vspace{1.0cm}

\newpage
\subsection{DialFrontendBridge}

Per rendere questa comunicazione bi-direzionale, abbiamo creato una classe DialFrontendBridge con la responsabilitá di rendere visibili dei metodi all'interno dell'oggetto window e quindi richiamabili tramite script dall'applicazione UWP.\\

L'invocazione di questi metodi comporta la successiva emissione di un determinato evento a coloro che vi si sottoscrivono, con la possibilitá del passaggio di parametri di tipo stringa.\\

Tramite l'utilizzo degli EventEmitter messi a disposizione dal core di Angular e definiti come mostrato nel codice sottostante, la classe DialFrontendBridge permette all'utilizzatore del servizio di sottoscriversi a determinati eventi pubblici, che quando richiamati emettono un determinato valore. RIFERIMENTO A CODICE \\

\vspace{1.0cm}
\begin{lstlisting}[caption={EventEmitter esposti da DialFrontendBridge},style=javaScriptCode]
public onRotationEvent = new EventEmitter<{tag: string, degree: string}>();
public onPressedRotationEvent = new EventEmitter<{tag: string, degree: string}>();
public onClickEvent = new EventEmitter<string>();
public onInvokeEvent = new EventEmitter<string>();
public onScreenContactStartedEvent = new EventEmitter<{x: string, y: string}>();
public onScreenContactContinuedEvent = new EventEmitter<{x: string, y: string}>();
public onScreenContactEndedEvent = new EventEmitter();
\end{lstlisting} 
\vspace{1.0cm}

Affinché questi metodi possano essere richiamati tramite script dall'applicazione UWP é stato necessario inserire l'istanza della classe all'interno dell'oggetto window, cosi da renderlo visibile e utilizzabile dall'esterno.\\

\vspace{1.0cm}
\begin{lstlisting}[caption={Inserimento classe DialFrontendbridge in window },style=javaScriptCode]
(windowa as any).DialFrontendBridge = this.dialFrontendbridge;
\end{lstlisting} 
\vspace{1.0cm}

\newpage
\vspace{1.0cm}
\begin{lstlisting}[caption={Metodi esposti da DialFrontendBridge},style=javaScriptCode]
   /**
     * Metodo richiamato da UWP che notifica la rotazione del Microsoft Dial.
     * @param tag Identificatore dell'elemento che ha eseguito la rotazione
     * @param degree Gradi della rotazione
     */
    public RotationEvent(tag: string, degree: string): string{
        this.onRotationEvent.emit({tag, degree});
        return degree;
    }

    /**
     * Metodo richiamato da UWP che notifica la rotazione de
     * l Microsoft Dial con il Dial premuto.
     * @param tag Identificatore dell'elemento che ha eseguito la rotazione
     * @param degree Gradi della rotazione
     */
    public PressedRotationEvent(tag: string, degree: string): string{
        this.onPressedRotationEvent.emit({tag, degree});
        return degree;
    }

    /**
     * Metodo richiamato dall'UWP che notifica la pressione del del Microsoft Dial.
     * @param tag Identificatore dell'elemeto che ha eseguito il click sul Dial.
     */
    public ClickEvent(tag: string){
            this.onClickEvent.emit(tag);
    }

    /**
     * Metodo richiamato dall'UWP che notifica l'invocazione di un elemento di Menu.
     * @param tag Identificatore del MenuItem che ha eseguito l'invoke.
     */
    public InvokeEvent(tag: string){
        this.onInvokeEvent.emit(tag);
    }

    /**
     * Metodo richiamato dall'UWP che notifica il contatto del 
     * dispositivo Dial con lo schermo nel punto con coordinate x e y.
     * @param x Coordinata x della posizione
     * @param y Coordinata y della posizione
     */
    public ScreenContactStartedEvent(x: string, y: string){
        this.onScreenContactStartedEvent.emit({x, y});
    }

    /**
     * Metodo richiamato dall'UWP che notifica lo spostamento del 
     * dispositivo Dial sullo schermo nel punto con coordinate x e y.
     * @param x Coordinata x della posizione
     * @param y Coordinata y della posizione
     */
    public ScreenContactContinuedEvent(x: string, y: string){
        this.onScreenContactContinuedEvent.emit({x, y});
    }

    /**
     * Metodo richiamato dall'UWP che norifica 
     * quando il Dial viene rimosso dallo schermo
     */
    public ScreenContactEndedEvent(){
        this.onScreenContactEndedEvent.emit();
    }
\end{lstlisting} 
\vspace{1.0cm}

\subsection{DialMenuLoader}

\subsection{Widget}
 
\section{Applicazione UWP}